package main

import (
	"testing"
)

func TestSelectLinesAfter(t *testing.T) {
	input1 := []string{
		"не будет различать верхний и нижний регистр.\nзаставить его находить только определенные слова.\nвыбирает строки, которые не совпадают.\nпоказывает номер строки с запрошенными словами.\nудаляет префикс из имени файла Unix в выводе.\nрекурсивный поиск в каталогах.\nкак -r, но следуйте всем символическим ссылкам.\nпоказывает только имена файлов с выделенными строками.\nПоказывает только одно количество выбранных строк для каждого файла.\nОтображает совпадающие шаблоны в цветах.",
	}

	input2 := []string{
		"выбирает строки",
	}

	input3 := []int{
		3,
	}

	expectations := []string{
		"показывает номер строки с запрошенными словами.\nудаляет префикс из имени файла Unix в выводе.\nрекурсивный поиск в каталогах.",
	}

	for i := 0; i < len(input1); i++ {
		result := SelectLinesAfter(input1[i], input2[i], input3[i])
		if result != expectations[i] {
			t.Fatalf("\nbad result for: \n\"%s\"\n\"%s\"\n\"%d\"\nexpected: \n\"%s\"\ngot: \n\"%s\"\n",
				input1[i], input2[i], input3[i], expectations[i], result)
		}
	}
}

func TestSelectLinesBefore(t *testing.T) {
	input1 := []string{
		"не будет различать верхний и нижний регистр.\nзаставить его находить только определенные слова.\nвыбирает строки, которые не совпадают.\nпоказывает номер строки с запрошенными словами.\nудаляет префикс из имени файла Unix в выводе.\nрекурсивный поиск в каталогах.\nкак -r, но следуйте всем символическим ссылкам.\nпоказывает только имена файлов с выделенными строками.\nПоказывает только одно количество выбранных строк для каждого файла.\nОтображает совпадающие шаблоны в цветах.",
	}

	input2 := []string{
		"только имена файлов",
	}

	input3 := []int{
		3,
	}

	expectations := []string{
		"удаляет префикс из имени файла Unix в выводе.\nрекурсивный поиск в каталогах.\nкак -r, но следуйте всем символическим ссылкам.",
	}

	for i := 0; i < len(input1); i++ {
		result := SelectLinesBefore(input1[i], input2[i], input3[i])
		if result != expectations[i] {
			t.Fatalf("\nbad result for: \n\"%s\"\n\"%s\"\n\"%d\"\nexpected: \n\"%s\"\ngot: \n\"%s\"\n",
				input1[i], input2[i], input3[i], expectations[i], result)
		}
	}
}

func TestSelectLinesAround(t *testing.T) {
	input1 := []string{
		"не будет различать верхний и нижний регистр.\nзаставить его находить только определенные слова.\nвыбирает строки, которые не совпадают.\nпоказывает номер строки с запрошенными словами.\nудаляет префикс из имени файла Unix в выводе.\nрекурсивный поиск в каталогах.\nкак -r, но следуйте всем символическим ссылкам.\nпоказывает только имена файлов с выделенными строками.\nПоказывает только одно количество выбранных строк для каждого файла.\nОтображает совпадающие шаблоны в цветах.",
	}

	input2 := []string{
		"удаляет префикс",
	}

	input3 := []int{
		5,
	}

	expectations := []string{
		"выбирает строки, которые не совпадают.\nпоказывает номер строки с запрошенными словами.\nудаляет префикс из имени файла Unix в выводе.\nрекурсивный поиск в каталогах.\nкак -r, но следуйте всем символическим ссылкам.",
	}

	for i := 0; i < len(input1); i++ {
		result := SelectLinesAround(input1[i], input2[i], input3[i])
		if result != expectations[i] {
			t.Fatalf("\nbad result for: \n\"%s\"\n\"%s\"\n\"%d\"\nexpected: \n\"%s\"\ngot: \n\"%s\"\n",
				input1[i], input2[i], input3[i], expectations[i], result)
		}
	}
}

func TestGetLinesCount(t *testing.T) {
	input1 := []string{
		"не будет различать верхний и нижний регистр.\nзаставить его находить только определенные слова.\nвыбирает строки, которые не совпадают.\nпоказывает номер строки с запрошенными словами.\nудаляет префикс из имени файла Unix в выводе.\nрекурсивный поиск в каталогах.\nкак -r, но следуйте всем символическим ссылкам.\nпоказывает только имена файлов с выделенными строками.\nПоказывает только одно количество выбранных строк для каждого файла.\nОтображает совпадающие шаблоны в цветах.",
	}

	input2 := []string{
		"показывает",
	}

	expectations := []int{
		2,
	}

	for i := 0; i < len(input1); i++ {
		result := GetLinesCount(input1[i], input2[i])
		if result != expectations[i] {
			t.Fatalf("\nbad result for: \n\"%s\"\n\"%s\"\nexpected: \n\"%d\"\ngot: \n\"%d\"\n",
				input1[i], input2[i], expectations[i], result)
		}
	}
}

func TestSelectLineIgnoringCase(t *testing.T) {
	input1 := []string{
		"не будет различать верхний и нижний регистр.\nзаставить его находить только определенные слова.\nвыбирает строки, которые не совпадают.\nпоказывает номер строки с запрошенными словами.\nудаляет префикс из имени файла Unix в выводе.\nрекурсивный поиск в каталогах.\nкак -r, но следуйте всем символическим ссылкам.\nпоказывает только имена файлов с выделенными строками.\nПоказывает только одно количество выбранных строк для каждого файла.\nОтображает совпадающие шаблоны в цветах.",
	}

	input2 := []string{
		"Отображает",
	}

	expectations := []string{
		"Отображает совпадающие шаблоны в цветах.",
	}

	for i := 0; i < len(input1); i++ {
		result := SelectLineIgnoringCase(input1[i], input2[i])
		if result != expectations[i] {
			t.Fatalf("\nbad result for: \n\"%s\"\n\"%s\"\nexpected: \n\"%s\"\ngot: \n\"%s\"\n",
				input1[i], input2[i], expectations[i], result)
		}
	}
}

func TestSelectLinesWithout(t *testing.T) {
	input1 := []string{
		"не будет различать верхний и нижний регистр.\nзаставить его находить только определенные слова.\nвыбирает строки, которые не совпадают.\nпоказывает номер строки с запрошенными словами.\nудаляет префикс из имени файла Unix в выводе.\nрекурсивный поиск в каталогах.\nкак -r, но следуйте всем символическим ссылкам.\nпоказывает только имена файлов с выделенными строками.\nПоказывает только одно количество выбранных строк для каждого файла.\nОтображает совпадающие шаблоны в цветах.",
	}

	input2 := []string{
		"строки",
	}

	expectations := []string{
		"не будет различать верхний и нижний регистр.\nзаставить его находить только определенные слова.\nудаляет префикс из имени файла Unix в выводе.\nрекурсивный поиск в каталогах.\nкак -r, но следуйте всем символическим ссылкам.\nпоказывает только имена файлов с выделенными строками.\nПоказывает только одно количество выбранных строк для каждого файла.\nОтображает совпадающие шаблоны в цветах.",
	}

	for i := 0; i < len(input1); i++ {
		result := SelectLinesWithout(input1[i], input2[i])
		if result != expectations[i] {
			t.Fatalf("\nbad result for: \n\"%s\"\n\"%s\"\nexpected: \n\"%s\"\ngot: \n\"%s\"\n",
				input1[i], input2[i], expectations[i], result)
		}
	}
}

func TestSelectExactLine(t *testing.T) {
	input1 := []string{
		"не будет различать верхний и нижний регистр.\nзаставить его находить только определенные слова.\nвыбирает строки, которые не совпадают.\nпоказывает номер строки с запрошенными словами.\nудаляет префикс из имени файла Unix в выводе.\nрекурсивный поиск в каталогах.\nкак -r, но следуйте всем символическим ссылкам.\nпоказывает только имена файлов с выделенными строками.\nПоказывает только одно количество выбранных строк для каждого файла.\nОтображает совпадающие шаблоны в цветах.",
	}

	input2 := []string{
		"рекурсивный поиск в каталогах.",
	}

	expectations := []string{
		"рекурсивный поиск в каталогах.",
	}

	for i := 0; i < len(input1); i++ {
		result := SelectExactLine(input1[i], input2[i])
		if result != expectations[i] {
			t.Fatalf("\nbad result for: \n\"%s\"\n\"%s\"\nexpected: \n\"%s\"\ngot: \n\"%s\"\n",
				input1[i], input2[i], expectations[i], result)
		}
	}
}

func TestGetLineNumber(t *testing.T) {
	input1 := []string{
		"не будет различать верхний и нижний регистр.\nзаставить его находить только определенные слова.\nвыбирает строки, которые не совпадают.\nпоказывает номер строки с запрошенными словами.\nудаляет префикс из имени файла Unix в выводе.\nрекурсивный поиск в каталогах.\nкак -r, но следуйте всем символическим ссылкам.\nпоказывает только имена файлов с выделенными строками.\nПоказывает только одно количество выбранных строк для каждого файла.\nОтображает совпадающие шаблоны в цветах.",
	}

	input2 := []string{
		"показывает номер строки",
	}

	expectations := []int{
		3,
	}

	for i := 0; i < len(input1); i++ {
		result := GetLineNumber(input1[i], input2[i])
		if result != expectations[i] {
			t.Fatalf("\nbad result for: \n\"%s\"\n\"%s\"\nexpected: \n\"%d\"\ngot: \n\"%d\"\n",
				input1[i], input2[i], expectations[i], result)
		}
	}
}
